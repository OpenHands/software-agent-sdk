"""Claude-style delegation tool implementations.

This module provides the shared state manager and executors for the
Claude Code-style delegation tools (Task, TaskOutput, TaskStop).

Architecture:
    ClaudeDelegationManager holds the shared state (sub-agent conversations,
    background threads, results) and is shared between all three executors.
    This mirrors how BrowserToolExecutor is shared across all browser tools.
"""

import threading
import uuid
from dataclasses import dataclass, field
from enum import StrEnum
from typing import TypeVar

from openhands.sdk import Agent, Observation
from openhands.sdk.conversation.impl.local_conversation import LocalConversation
from openhands.sdk.conversation.response_utils import get_agent_final_response
from openhands.sdk.logger import get_logger
from openhands.sdk.tool.tool import ToolExecutor
from openhands.tools.claude.definition import (
    TaskAction,
    TaskObservation,
    TaskOutputAction,
    TaskOutputObservation,
    TaskStopAction,
    TaskStopObservation,
)
from openhands.tools.delegate.registration import get_agent_factory


logger = get_logger(__name__)


class TaskStatus(StrEnum):
    """
    Represents the lifecycle states of a task.

    Used to track progress from initiation through to various forms
    of completion or failure.
    """

    RUNNING = "running"
    """The task is currently being processed by an agent."""

    SUCCEEDED = "succeeded"
    """The task finished successfully and returned a valid result or response."""

    EMPTY_SUCCESS = "empty_success"
    """The task finished without errors, but produced no data or expected output."""

    ERROR = "error"
    """The task failed to complete due to an unhandled exception or system fault."""

    STOPPED = "stopped"
    """The task was manually terminated or cancelled before it could finish."""


@dataclass
class TaskState:
    """
    State of a running or completed sub-agent task.

    Note that a TaskState can only have either a result or
    an error that is not None.
    """

    id: str
    """Unique identifier of the task."""
    conversation: LocalConversation
    """Conversation state of the task."""
    status: TaskStatus
    """Task status."""
    result: str | None = None
    """Result of the task if one was produced."""
    error: str | None = None
    """Error generated by the task if one was produced."""

    thread: threading.Thread | None = None

    _lock: threading.Lock = field(default_factory=threading.Lock)

    def set_completed(self, result: str) -> None:
        """Set task as completed."""
        with self._lock:
            self.result = result
            self.error = None
            if self.result:
                self.status = TaskStatus.SUCCEEDED
            else:
                self.status = TaskStatus.EMPTY_SUCCESS

    def set_error(self, error: str) -> None:
        """Set task as failed with an error."""
        with self._lock:
            self.error = error
            self.result = None
            self.status = TaskStatus.ERROR

    def stop(self) -> None:
        """Stop the task."""
        if self.status == TaskStatus.RUNNING:
            with self._lock:
                self.status = TaskStatus.STOPPED
                self.result = None
                self.error = None


class DelegationManager:
    """Shared state manager for Claude-style delegation tools.

    Manages the lifecycle of sub-agent tasks, including creation, execution
    (synchronous and background), output retrieval, and stopping.

    This manager is shared between TaskExecutor, TaskOutputExecutor, and
    TaskStopExecutor to coordinate task state.

    Args:
        max_children: Maximum number of child tasks to create.
    """

    def __init__(self, max_children: int = 5):
        assert max_children > 0, "max_children must be > 0"
        self._max_children: int = max_children
        self._parent_conversation: LocalConversation | None = None
        self._tasks: dict[str, TaskState] = {}
        self._lock = threading.RLock()

    def _generate_task_id(self) -> str:
        """Generate a unique task ID."""
        short_uuid = uuid.uuid4().hex[:8]
        return f"task_{short_uuid}"

    def _ensure_parent(self, conversation: LocalConversation) -> None:
        """Set the parent conversation on first call."""
        if self._parent_conversation is None:
            self._parent_conversation = conversation

    @property
    def parent_conversation(self) -> LocalConversation:
        if self._parent_conversation is None:
            raise RuntimeError(
                "Parent conversation not set. This should be set automatically "
                "on the first call to the executor."
            )
        return self._parent_conversation

    def start_task(
        self,
        prompt: str,
        subagent_type: str = "default",
        model: str | None = None,  # noqa: ARG002
        run_in_background: bool = False,
        resume: str | None = None,
        max_turns: int | None = None,
        description: str | None = None,
        conversation: LocalConversation | None = None,
    ) -> TaskState:
        """Start a new task or resume an existing one.

        Args:
            prompt: The task description for the sub-agent.
            subagent_type: Type of agent to use (maps to registered agent factories).
            model: Optional model override for the sub-agent LLM.
            run_in_background: If True, run in a background thread.
            resume: Task ID to resume (continues existing conversation).
            max_turns: Maximum number of agent iterations.
            description: Short description for the task (used in visualizer label).
            conversation: Parent conversation (set on first call).

        Returns:
            TaskState with the task's current state.

        Raises:
            ValueError: If resume ID not found or capacity exceeded.
        """
        if conversation:
            self._ensure_parent(conversation)

        if resume:
            task = self._resume_task(prompt, resume, run_in_background)
            return task

        # Check capacity
        with self._lock:
            active_count = sum(1 for t in self._tasks.values() if t.status == "running")
            if active_count >= self._max_children:
                raise ValueError(
                    f"Cannot start new task. Already have {active_count} "
                    f"running tasks, maximum is {self._max_children}"
                )

        # create a new agent assigned with the given task
        task_id = self._generate_task_id()
        worker_agent = self._create_new_sub_agent(subagent_type)
        sub_conversation = self._create_new_conversation(
            description=description,
            max_turns=max_turns,
            task_id=task_id,
            worker_agent=worker_agent,
        )

        task = TaskState(
            id=task_id,
            conversation=sub_conversation,
            status=TaskStatus.RUNNING,
        )

        with self._lock:
            self._tasks[task_id] = task

        logger.info(f"Created task '{task_id}' with agent type '{subagent_type}'")

        self._run_task(task, prompt, run_in_background)

        return task

    def _create_new_conversation(
        self,
        description: str | None,
        max_turns: int | None,
        task_id: str,
        worker_agent: Agent,
    ) -> LocalConversation:
        # Create sub-visualizer
        sub_visualizer = None
        agent_label = description or task_id

        parent_visualizer = self.parent_conversation._visualizer
        if parent_visualizer is not None:
            sub_visualizer = parent_visualizer.create_sub_visualizer(agent_label)

        # Create conversation with optional max_turns
        conv_kwargs: dict = {
            "agent": worker_agent,
            "workspace": self.parent_conversation.state.workspace.working_dir,
            "visualizer": sub_visualizer,
        }
        if max_turns is not None:
            conv_kwargs["max_iteration_per_run"] = max_turns

        sub_conversation = LocalConversation(**conv_kwargs)
        return sub_conversation

    def _create_new_sub_agent(self, subagent_type: str) -> Agent:
        """Private method to create a new sub-agent."""
        # todo: implement change of LLM
        parent = self.parent_conversation
        parent_llm = parent.agent.llm

        # Get agent factory
        factory = get_agent_factory(subagent_type)

        # Create sub-agent LLM (disable streaming)
        llm_updates: dict = {"stream": False}
        sub_agent_llm = parent_llm.model_copy(update=llm_updates)

        worker_agent = factory.factory_func(sub_agent_llm)
        return worker_agent

    def _resume_task(
        self,
        prompt: str,
        resume: str,
        run_in_background: bool,
    ) -> TaskState:
        with self._lock:
            task = self._tasks.get(resume)
        if task is None:
            raise ValueError(
                f"Task '{resume}' not found. "
                f"Available tasks: {', '.join(self._tasks.keys())}"
            )

        # Reset status for resumed task
        task.status = TaskStatus.RUNNING
        task.result = None
        task.error = None
        self._run_task(task, prompt, run_in_background)
        return task

    def _run_task(self, task: TaskState, prompt: str, run_in_background: bool) -> None:
        """Run a task synchronously or in the background."""
        # Get parent name for sender info
        parent_name = None
        parent = self.parent_conversation
        if hasattr(parent, "_visualizer") and parent._visualizer is not None:
            parent_name = getattr(parent._visualizer, "_name", None)

        if run_in_background:

            def _run() -> None:
                try:
                    task.conversation.send_message(prompt, sender=parent_name)
                    task.conversation.run()
                    result = get_agent_final_response(task.conversation.state.events)
                    task.set_completed(result)
                    logger.info(f"Background task '{task.id}' completed.")
                except Exception as e:
                    task.set_error(str(e))
                    logger.error(
                        f"Background task '{task.id}' failed: {e}",
                        exc_info=True,
                    )

            thread = threading.Thread(target=_run, name=f"Task-{task.id}", daemon=True)
            task.thread = thread
            thread.start()
        else:
            try:
                task.conversation.send_message(prompt, sender=parent_name)
                task.conversation.run()
                result = get_agent_final_response(task.conversation.state.events)
                task.set_completed(result)
            except Exception as e:
                task.set_error(str(e))
                logger.warning(f"Task {task.id} failed with error: {str(e)}")

    def get_task_output(
        self, task_id: str, block: bool = True, timeout_ms: int = 30000
    ) -> TaskState:
        """Get the output from a task.

        Args:
            task_id: The ID of the task.
            block: Whether to wait for completion.
            timeout_ms: Maximum wait time in milliseconds.

        Returns:
            The TaskState with current status and result.

        Raises:
            ValueError: If task_id not found.
        """
        with self._lock:
            task = self._tasks.get(task_id)

        if task is None:
            raise ValueError(
                f"Task '{task_id}' not found. "
                f"Available tasks: {', '.join(self._tasks.keys())}"
            )

        if block and task.thread is not None and task.status == TaskStatus.RUNNING:
            timeout_sec = timeout_ms / 1000.0
            task.thread.join(timeout=timeout_sec)

        return task

    def stop_task(self, task_id: str) -> TaskState | None:
        """Stop a running task.

        Args:
            task_id: The ID of the task to stop.

        Returns:
            The TaskState if found, None otherwise.
        """
        with self._lock:
            task = self._tasks.get(task_id)

        if task:
            task.stop()

        return task

    def close(self) -> None:
        """Clean up all tasks and wait for background threads."""
        with self._lock:
            tasks = list(self._tasks.values())

        for task in tasks:
            if task.thread and task.thread.is_alive():
                task.set_error("Manager closing.")

        for task in tasks:
            if task.thread and task.thread.is_alive():
                task.thread.join(timeout=5.0)


T = TypeVar("T", bound=Observation)


def _generate_observation_from_task[T: Observation](
    task: TaskState,
    observation_cls: type[T],
) -> T:
    """Helper function to generate uniform observations from task state."""
    match task.status:
        case TaskStatus.RUNNING:
            return observation_cls.from_text(
                text=(
                    f"Task '{task.id}' running in background. "
                    f'Use task_output(task_id="{task.id}") to check on it.'
                ),
                task_id=task.id,
                status="running",
            )
        case TaskStatus.SUCCEEDED:
            return observation_cls.from_text(
                text=task.result or "Task succeeded.",
                task_id=task.id,
                status="completed",
            )
        case TaskStatus.EMPTY_SUCCESS:
            return observation_cls.from_text(
                text="Task completed with no result.",
                task_id=task.id,
                status="completed",
            )
        case TaskStatus.ERROR:
            return observation_cls.from_text(
                text=task.error or "Task failed.",
                task_id=task.id,
                status="error",
                is_error=True,
            )
        case TaskStatus.STOPPED:
            return observation_cls.from_text(
                text=f"Task '{task.id}' was stopped.",
                task_id=task.id,
                status="stopped",
                is_error=False,  # not an error â€” deliberate action
            )
        case _:
            # this should never happen, but raising an error
            # in the case this comment is wrong
            raise RuntimeError(f"Unknown task status: {task.status}")


class TaskExecutor(ToolExecutor):
    """Executor for the Task tool.

    Handles creating and running sub-agent tasks, both synchronous
    and background.
    """

    def __init__(self, manager: DelegationManager):
        self._manager = manager

    def __call__(
        self,
        action: "TaskAction",
        conversation: LocalConversation | None = None,
    ) -> "TaskObservation":
        try:
            task = self._manager.start_task(
                prompt=action.prompt,
                subagent_type=action.subagent_type,
                model=action.model,
                run_in_background=action.run_in_background,
                resume=action.resume,
                max_turns=action.max_turns,
                description=action.description,
                conversation=conversation,
            )

            return _generate_observation_from_task(
                task=task, observation_cls=TaskObservation
            )

        except Exception as e:
            logger.error(f"Task execution failed: {e}", exc_info=True)
            return TaskObservation.from_text(
                text=f"Failed to execute task: {str(e)}",
                task_id="unknown",
                status=TaskStatus.ERROR,
                is_error=True,
            )

    def close(self) -> None:
        self._manager.close()


class TaskOutputExecutor(ToolExecutor):
    """Executor for the TaskOutput tool.

    Retrieves output from background tasks, optionally blocking
    until completion.
    """

    def __init__(self, manager: DelegationManager):
        self._manager = manager

    def __call__(
        self,
        action: "TaskOutputAction",
        conversation: LocalConversation | None = None,  # noqa: ARG002
    ) -> "TaskOutputObservation":
        try:
            task = self._manager.get_task_output(
                task_id=action.task_id,
                block=action.block,
                timeout_ms=action.timeout,
            )

            return _generate_observation_from_task(task, TaskOutputObservation)

        except ValueError as e:
            return TaskOutputObservation.from_text(
                text=str(e),
                task_id=action.task_id,
                status=TaskStatus.ERROR,
                is_error=True,
            )


class TaskStopExecutor(ToolExecutor):
    """Executor for the TaskStop tool.

    Stops running background tasks.
    """

    def __init__(self, manager: DelegationManager):
        self._manager = manager

    def __call__(
        self,
        action: "TaskStopAction",
        conversation: LocalConversation | None = None,  # noqa: ARG002
    ) -> "TaskStopObservation":
        task = self._manager.stop_task(action.task_id)

        if task is None:
            return TaskStopObservation.from_text(
                text=f"Task '{action.task_id}' not found.",
                task_id=action.task_id,
                status="not_found",
                is_error=True,
            )

        return TaskStopObservation.from_text(
            text=f"Task '{action.task_id}' has been stopped.",
            task_id=task.id,
            status=TaskStatus.STOPPED,
        )
