"""Claude-style delegation tool implementations.

This module provides the shared state manager and executors for the
Claude Code-style delegation tools (Task, TaskOutput, TaskStop).

Architecture:
    ClaudeDelegationManager holds the shared state (sub-agent conversations,
    background threads, results) and is shared between all three executors.
    This mirrors how BrowserToolExecutor is shared across all browser tools.
"""

import json
import shutil
import tempfile
import threading
import uuid
from enum import StrEnum
from pathlib import Path
from typing import Self, TypeVar

from pydantic import BaseModel, ConfigDict, Field, PrivateAttr

from openhands.sdk import Agent, Observation
from openhands.sdk.conversation.impl.local_conversation import LocalConversation
from openhands.sdk.conversation.response_utils import get_agent_final_response
from openhands.sdk.logger import get_logger
from openhands.sdk.tool.tool import ToolExecutor
from openhands.tools.claude.definition import (
    TaskAction,
    TaskObservation,
    TaskOutputAction,
    TaskOutputObservation,
    TaskStopAction,
    TaskStopObservation,
)
from openhands.tools.delegate.registration import get_agent_factory


logger = get_logger(__name__)


class TaskStatus(StrEnum):
    """
    Represents the lifecycle states of a task.

    Used to track progress from initiation through to various forms
    of completion or failure.
    """

    RUNNING = "running"
    """The task is currently being processed by an agent."""

    SUCCEEDED = "succeeded"
    """The task finished successfully and returned a valid result or response."""

    EMPTY_SUCCESS = "empty_success"
    """The task finished without errors, but produced no data or expected output."""

    ERROR = "error"
    """The task failed to complete due to an unhandled exception or system fault."""

    STOPPED = "stopped"
    """The task was manually terminated or cancelled before it could finish."""


class TaskState(BaseModel):
    """
    State of a running or completed sub-agent task.

    Note that a TaskState can only have either a result or
    an error that is not None.
    """

    model_config = ConfigDict(arbitrary_types_allowed=True)

    id: str = Field(description="Unique identifier of the task.")
    status: TaskStatus = Field(description="Task status.")
    result: str | None = Field(
        default=None, description="Result of the task if one was produced."
    )
    error: str | None = Field(
        default=None,
        description="Error generated by the task if one was produced.",
    )
    conversation: LocalConversation | None = Field(
        default=None,
        exclude=True,
        description="Conversation state of the task. None for evicted/inactive tasks.",
    )
    thread: threading.Thread | None = Field(
        default=None,
        exclude=True,
        description="Thread running the task. None for evicted/inactive tasks.",
    )

    _lock: threading.Lock = PrivateAttr(default_factory=threading.Lock)

    def set_completed(self, result: str) -> None:
        """Set task as completed."""
        with self._lock:
            self.result = result
            self.error = None
            if self.result:
                self.status = TaskStatus.SUCCEEDED
            else:
                self.status = TaskStatus.EMPTY_SUCCESS

    def set_error(self, error: str) -> None:
        """Set task as failed with an error."""
        with self._lock:
            self.error = error
            self.result = None
            self.status = TaskStatus.ERROR

    def stop(self) -> None:
        """Stop the task."""
        with self._lock:
            if self.status == TaskStatus.RUNNING:
                self.status = TaskStatus.STOPPED
                self.result = None
                self.error = None

    def save_to_disk(self, filename_path: Path) -> None:
        """Persist task to disk atomically (best-effort)."""
        tmp_file = filename_path.with_suffix(".tmp")
        tmp_file.write_text(self.model_dump_json())
        tmp_file.replace(filename_path.with_suffix(".json"))

    @classmethod
    def load_from_disk(cls, file_path: Path) -> Self | None:
        """Load a persisted task from disk."""
        if file_path.suffix != ".json":
            file_path = file_path.with_suffix(".json")
        if not file_path.exists():
            return None
        return cls.model_validate_json(file_path.read_text())


class DelegationManager:
    """Shared state manager for Claude-style delegation tools.

    Manages the lifecycle of sub-agent tasks, including creation, execution
    (synchronous and background), output retrieval, and stopping.

    This manager is shared between TaskExecutor, TaskOutputExecutor, and
    TaskStopExecutor to coordinate task state.

    Args:
        max_tasks: Maximum number of tasks running.
    """

    def __init__(self, max_tasks: int = 10):
        assert max_tasks > 0, "max_tasks must be > 0"
        self._max_tasks: int = max_tasks
        self._parent_conversation: LocalConversation | None = None
        self._active_tasks: dict[str, TaskState] = {}
        self._inactive_tasks: set[str] = set()
        self._task_id_to_uuid: dict[str, uuid.UUID] = {}
        self._tmp_dir = Path(tempfile.mkdtemp(prefix="openhands_tasks_"))
        self._lock = threading.RLock()

    def _generate_task_id(self) -> str:
        """Generate a unique task ID."""
        while True:
            uuid_ = uuid.uuid4()
            short_uuid = str(uuid_)[:8]
            task_id = f"task_{short_uuid}"
            if (
                task_id not in self._active_tasks
                and task_id not in self._inactive_tasks
            ):
                self._task_id_to_uuid[task_id] = uuid_
                return task_id

    def _ensure_parent(self, conversation: LocalConversation) -> None:
        """Set the parent conversation on first call."""
        if self._parent_conversation is None:
            self._parent_conversation = conversation

    @property
    def parent_conversation(self) -> LocalConversation:
        if self._parent_conversation is None:
            raise RuntimeError(
                "Parent conversation not set. This should be set automatically "
                "on the first call to the executor."
            )
        return self._parent_conversation

    def _get_task_directory(self, task_id: str) -> Path:
        """Return the task directory."""
        return self._tmp_dir / str(self._task_id_to_uuid[task_id])

    def _evict_task(self, task_id: str) -> None:
        """
        Move a complete task or a stopped one from activate to inactive.
        The task is persisted as well as the conversation state.
        """
        with self._lock:
            if task_id in self._active_tasks:
                task = self._active_tasks.pop(task_id)
                self._inactive_tasks.add(task_id)

                # save task in its folder
                task_dir = self._get_task_directory(task_id)
                task_dir.mkdir(parents=True, exist_ok=True)
                task.save_to_disk(task_dir / "task_state")

    def start_task(
        self,
        prompt: str,
        subagent_type: str = "default",
        model: str | None = None,  # noqa: ARG002
        run_in_background: bool = False,
        resume: str | None = None,
        max_turns: int | None = None,
        description: str | None = None,
        conversation: LocalConversation | None = None,
    ) -> TaskState:
        """Start a new task or resume an existing one.

        Args:
            prompt: The task description for the sub-agent.
            subagent_type: Type of agent to use (maps to registered agent factories).
            model: Optional model override for the sub-agent LLM.
            run_in_background: If True, run in a background thread.
            resume: Task ID to resume (continues existing conversation).
            max_turns: Maximum number of agent iterations.
            description: Short description for the task (used in visualizer label).
            conversation: Parent conversation (set on first call).

        Returns:
            TaskState with the task's current state.

        Raises:
            ValueError: If resume ID not found or capacity exceeded.
        """
        if conversation:
            self._ensure_parent(conversation)

        with self._lock:
            active_count = sum(
                1 for t in self._active_tasks.values() if t.status == TaskStatus.RUNNING
            )
            if active_count >= self._max_tasks:
                raise ValueError(
                    f"Cannot start new task. Already have {active_count} "
                    f"tasks, maximum is {self._max_tasks}"
                )

            if resume:
                task = self._resolve_resumed_task(resume, subagent_type)
            else:
                task = self._create_new_task(
                    subagent_type=subagent_type,
                    description=description,
                    max_turns=max_turns,
                )
            self._active_tasks[task.id] = task

        logger.info(
            f"{'Resumed' if resume else 'Created'} task '{task.id}' "
            f"with agent type '{subagent_type}'"
        )
        self._run_task(task, prompt, run_in_background)
        return task

    def _resolve_resumed_task(self, resume: str, subagent_type: str) -> TaskState:
        """Resolve a task to resume. Must be called under self._lock."""
        if resume in self._active_tasks:
            task = self._active_tasks[resume]
            if task.status == TaskStatus.RUNNING:
                raise ValueError(f"Task '{resume}' already running.")
            return task

        if resume not in self._inactive_tasks:
            all_ids = list(self._active_tasks.keys()) + list(self._inactive_tasks)
            raise ValueError(
                f"Task '{resume}' not found. Available tasks: {', '.join(all_ids)}"
            )

        # Load from disk
        task_dir = self._get_task_directory(resume)
        task = TaskState.load_from_disk(task_dir / "task_state")
        if task is None:
            all_ids = list(self._active_tasks.keys()) + list(self._inactive_tasks)
            raise ValueError(
                f"Task '{resume}' not found on disk. "
                f"Available tasks: {', '.join(all_ids)}"
            )

        try:
            base = json.loads((task_dir / "base_state.json").read_text())
        except Exception as e:
            raise ValueError(
                "Could not load base state from disk to resume conversation."
            ) from e

        worker_agent = self._generate_worker_agent(subagent_type)
        conversation = LocalConversation(
            agent=worker_agent,
            workspace=base["workspace"]["working_dir"],
            persistence_dir=self._tmp_dir,
            conversation_id=self._task_id_to_uuid[resume],
        )
        task.conversation = conversation
        task.status = TaskStatus.RUNNING
        return task

    def _create_new_task(
        self,
        subagent_type: str,
        description: str | None,
        max_turns: int | None,
    ) -> TaskState:
        """Create a fresh task. Must be called under self._lock."""
        task_id = self._generate_task_id()
        worker_agent = self._generate_worker_agent(subagent_type)
        sub_conversation = self._generate_conversation(
            description=description,
            max_turns=max_turns,
            task_id=task_id,
            worker_agent=worker_agent,
        )
        return TaskState(
            id=task_id,
            conversation=sub_conversation,
            status=TaskStatus.RUNNING,
        )

    def _generate_conversation(
        self,
        description: str | None,
        max_turns: int | None,
        task_id: str,
        worker_agent: Agent,
    ) -> LocalConversation:
        # Create sub-visualizer
        sub_visualizer = None
        agent_label = description or task_id

        parent_visualizer = self.parent_conversation._visualizer
        if parent_visualizer is not None:
            sub_visualizer = parent_visualizer.create_sub_visualizer(agent_label)

        # Create conversation with optional max_turns
        conv_kwargs: dict = {
            "agent": worker_agent,
            "workspace": self.parent_conversation.state.workspace.working_dir,
            "visualizer": sub_visualizer,
            # conversation are stored in the tmp_dir
            "persistence_dir": self._tmp_dir,
            "conversation_dir": self._task_id_to_uuid[task_id],
        }
        if max_turns is not None:
            conv_kwargs["max_iteration_per_run"] = max_turns

        conversation = LocalConversation(**conv_kwargs)
        return conversation

    def _generate_worker_agent(self, subagent_type: str) -> Agent:
        """Private method to create a new sub-agent."""
        # todo: implement change of LLM
        parent = self.parent_conversation
        parent_llm = parent.agent.llm

        # Get agent factory
        factory = get_agent_factory(subagent_type)

        # Create sub-agent LLM (disable streaming)
        llm_updates: dict = {"stream": False}
        sub_agent_llm = parent_llm.model_copy(update=llm_updates)

        worker_agent = factory.factory_func(sub_agent_llm)
        return worker_agent

    def _run_task(self, task: TaskState, prompt: str, run_in_background: bool) -> None:
        """Run a task synchronously or in the background."""
        assert task.conversation is not None
        # Get parent name for sender info
        parent_name = None
        parent = self.parent_conversation
        if hasattr(parent, "_visualizer") and parent._visualizer is not None:
            parent_name = getattr(parent._visualizer, "_name", None)

        if run_in_background:

            def _run() -> None:
                assert task.conversation is not None
                try:
                    task.conversation.send_message(prompt, sender=parent_name)
                    task.conversation.run()
                    if task.status == TaskStatus.STOPPED:
                        # task was stopped: don't overwrite
                        return
                    result = get_agent_final_response(task.conversation.state.events)
                    task.set_completed(result)
                    logger.info(f"Background task '{task.id}' completed.")
                except Exception as e:
                    if task.status == TaskStatus.STOPPED:
                        # task was stopped: don't overwrite
                        return
                    task.set_error(str(e))
                    logger.error(
                        f"Background task '{task.id}' failed: {e}",
                        exc_info=True,
                    )
                finally:
                    self._evict_task(task.id)

            thread = threading.Thread(target=_run, name=f"Task-{task.id}", daemon=True)
            task.thread = thread
            thread.start()
        else:
            try:
                task.conversation.send_message(prompt, sender=parent_name)
                task.conversation.run()
                result = get_agent_final_response(task.conversation.state.events)
                task.set_completed(result)
            except Exception as e:
                task.set_error(str(e))
                logger.warning(f"Task {task.id} failed with error: {str(e)}")
            finally:
                self._evict_task(task.id)

    def get_task_output(
        self, task_id: str, block: bool = True, timeout_ms: int = 30000
    ) -> TaskState:
        """Get the output from a task.

        Args:
            task_id: The ID of the task.
            block: Whether to wait for completion.
            timeout_ms: Maximum wait time in milliseconds.

        Returns:
            The TaskState with current status and result.

        Raises:
            ValueError: If task_id not found.
        """
        with self._lock:
            if task_id in self._active_tasks:
                task = self._active_tasks[task_id]
            elif task_id not in self._inactive_tasks:
                all_ids = list(self._active_tasks.keys()) + list(self._inactive_tasks)
                raise ValueError(
                    f"Task '{task_id}' not found. Available tasks: {', '.join(all_ids)}"
                )
            else:
                task = TaskState.load_from_disk(
                    self._tmp_dir / str(self._task_id_to_uuid[task_id]) / "task_state"
                )
                if task is None:
                    all_ids = list(self._active_tasks.keys()) + list(
                        self._inactive_tasks
                    )
                    raise ValueError(
                        f"Task '{task_id}' not found on disk. "
                        f"Available tasks: {', '.join(all_ids)}"
                    )

        if block and task.thread is not None and task.status == TaskStatus.RUNNING:
            timeout_sec = timeout_ms / 1000.0
            task.thread.join(timeout=timeout_sec)
        return task

    def stop_task(self, task_id: str) -> TaskState | None:
        """Stop a running task.

        Args:
            task_id: The ID of the task to stop.

        Returns:
            The TaskState if found, None otherwise.
        """
        with self._lock:
            if task_id in self._active_tasks:
                task = self._active_tasks.get(task_id)
            else:
                task = None

        if task:
            task.stop()
            # Evict stopped tasks from running to inactive
            if task.status == TaskStatus.STOPPED:
                self._evict_task(task_id)

        return task

    def close(self) -> None:
        """Clean up all tasks and wait for background threads."""
        with self._lock:
            tasks = list(self._active_tasks.values())

        for task in tasks:
            if task.thread and task.thread.is_alive():
                task.set_error("Manager closing.")

        for task in tasks:
            if task.thread and task.thread.is_alive():
                task.thread.join(timeout=5.0)

        # Clean up temporary directory
        # and in-memory stores
        if self._tmp_dir.exists():
            shutil.rmtree(self._tmp_dir, ignore_errors=True)

        self._active_tasks.clear()
        self._inactive_tasks.clear()
        self._task_id_to_uuid.clear()


T = TypeVar("T", bound=Observation)


def _generate_observation_from_task[T: Observation](
    task: TaskState,
    observation_cls: type[T],
) -> T:
    """Helper function to generate uniform observations from task state."""
    match task.status:
        case TaskStatus.RUNNING:
            return observation_cls.from_text(
                text=(
                    f"Task '{task.id}' running in background. "
                    f'Use task_output(task_id="{task.id}") to check on it.'
                ),
                task_id=task.id,
                status="running",
            )
        case TaskStatus.SUCCEEDED:
            return observation_cls.from_text(
                text=task.result or "Task succeeded.",
                task_id=task.id,
                status="completed",
            )
        case TaskStatus.EMPTY_SUCCESS:
            return observation_cls.from_text(
                text="Task completed with no result.",
                task_id=task.id,
                status="completed",
            )
        case TaskStatus.ERROR:
            return observation_cls.from_text(
                text=task.error or "Task failed.",
                task_id=task.id,
                status="error",
                is_error=True,
            )
        case TaskStatus.STOPPED:
            return observation_cls.from_text(
                text=f"Task '{task.id}' was stopped.",
                task_id=task.id,
                status="stopped",
                is_error=False,  # not an error â€” deliberate action
            )
        case _:
            # this should never happen, but raising an error
            # in the case this comment is wrong
            raise RuntimeError(f"Unknown task status: {task.status}")


class TaskExecutor(ToolExecutor):
    """Executor for the Task tool.

    Handles creating and running sub-agent tasks, both synchronous
    and background.
    """

    def __init__(self, manager: DelegationManager):
        self._manager = manager

    def __call__(
        self,
        action: "TaskAction",
        conversation: LocalConversation | None = None,
    ) -> "TaskObservation":
        try:
            task = self._manager.start_task(
                prompt=action.prompt,
                subagent_type=action.subagent_type,
                model=action.model,
                run_in_background=action.run_in_background,
                resume=action.resume,
                max_turns=action.max_turns,
                description=action.description,
                conversation=conversation,
            )

            return _generate_observation_from_task(
                task=task, observation_cls=TaskObservation
            )

        except Exception as e:
            logger.error(f"Task execution failed: {e}", exc_info=True)
            return TaskObservation.from_text(
                text=f"Failed to execute task: {str(e)}",
                task_id="unknown",
                status=TaskStatus.ERROR,
                is_error=True,
            )

    def close(self) -> None:
        self._manager.close()


class TaskOutputExecutor(ToolExecutor):
    """Executor for the TaskOutput tool.

    Retrieves output from background tasks, optionally blocking
    until completion.
    """

    def __init__(self, manager: DelegationManager):
        self._manager = manager

    def __call__(
        self,
        action: "TaskOutputAction",
        conversation: LocalConversation | None = None,  # noqa: ARG002
    ) -> "TaskOutputObservation":
        try:
            task = self._manager.get_task_output(
                task_id=action.task_id,
                block=action.block,
                timeout_ms=action.timeout,
            )

            return _generate_observation_from_task(task, TaskOutputObservation)

        except ValueError as e:
            return TaskOutputObservation.from_text(
                text=str(e),
                task_id=action.task_id,
                status=TaskStatus.ERROR,
                is_error=True,
            )


class TaskStopExecutor(ToolExecutor):
    """Executor for the TaskStop tool.

    Stops running background tasks.
    """

    def __init__(self, manager: DelegationManager):
        self._manager = manager

    def __call__(
        self,
        action: "TaskStopAction",
        conversation: LocalConversation | None = None,  # noqa: ARG002
    ) -> "TaskStopObservation":
        task = self._manager.stop_task(action.task_id)

        if task is None:
            return TaskStopObservation.from_text(
                text=f"Task '{action.task_id}' not found.",
                task_id=action.task_id,
                status="not_found",
                is_error=True,
            )

        return TaskStopObservation.from_text(
            text=f"Task '{action.task_id}' has been stopped.",
            task_id=task.id,
            status=TaskStatus.STOPPED,
        )
